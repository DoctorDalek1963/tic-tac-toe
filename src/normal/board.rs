//! This module handles the board and the AI player.

use super::Coord;
use crate::shared::{
    self,
    board::{CellShape, WinnerError},
};
use itertools::Itertools;
use rand::seq::SliceRandom;

#[cfg(not(target_arch = "wasm32"))]
use rayon::prelude::*;

#[cfg(target_arch = "wasm32")]
use crate::fake_par_iter::VecParIter;

/// A struct to represent a simple tic-tac-toe board.
#[derive(Clone, Debug, PartialEq)]
pub struct Board {
    /// This 2D array represents all the cells, and is indexed as `cells[x][y]`, with the layout as so:
    ///
    /// ```text
    /// (0, 0) | (1, 0) | (2, 0)
    /// ------------------------
    /// (0, 1) | (1, 1) | (2, 1)
    /// ------------------------
    /// (0, 2) | (1, 2) | (2, 2)
    /// ```
    pub cells: [[Option<CellShape>; 3]; 3],

    /// This is the shape that the AI will play as.
    ///
    /// Board positions where this shape wins are considered good, and positions where the other
    /// shape wins are considered bad.
    pub ai_shape: CellShape,
}

impl Board {
    /// Create a new, empty board.
    pub fn new(shape_to_maximise: CellShape) -> Self {
        Self {
            cells: [[None; 3]; 3],
            ai_shape: shape_to_maximise,
        }
    }

    /// Return the winner of the current board. See [`shared::board::get_winner`].
    #[inline(always)]
    pub fn get_winner(&self) -> Result<(CellShape, [(usize, usize); 3]), WinnerError> {
        shared::board::get_winner(self.cells)
    }

    /// Return a vector of the coordinates of empty cells in the board.
    ///
    /// This method searches columns before rows.
    fn empty_cells(&self) -> Vec<Coord> {
        self.cells
            .iter()
            .enumerate()
            .flat_map(|(col, row_vec)| {
                row_vec
                    .iter()
                    .enumerate()
                    .filter_map(|(row, val)| match val {
                        None => Some((col, row)),
                        Some(_) => None,
                    })
                    .collect::<Vec<Coord>>()
            })
            .collect()
    }

    /// Evaluate the current position of the board, with the context of which shape is playing next.
    ///
    /// Positive numbers are always good for the AI; negative numbers are always good for the player.
    ///
    /// A win for the AI shape is 100. A win for the opponent is -100. For any other position, we
    /// iterate over all possible moves and evaluate each of them, swapping the shape for each
    /// recursion. We also multiple the result of the recursive call by 0.9. This means that
    /// creating or blocking a win in the short term is prioritised over long term play.
    pub fn evaluate_position(&self, shape_to_play: CellShape) -> i8 {
        match self.get_winner() {
            Ok((x, _)) if x == self.ai_shape => 100,
            Ok((x, _)) if x == self.ai_shape.other() => -100,
            Ok(_) => unreachable!(),
            Err(WinnerError::MultipleWinners | WinnerError::BoardFullNoWinner) => 0,
            Err(WinnerError::NoWinnerYet) => {
                let empty_cells = self.empty_cells();

                let map = empty_cells.par_iter().map(|&(x, y)| -> i8 {
                    let mut new_board = self.clone();
                    new_board.cells[x][y] = Some(shape_to_play);
                    // Further moves after this one are considered less important than creating or
                    // blocking a win in the short term
                    (0.9 * new_board.evaluate_position(shape_to_play.other()) as f32) as i8
                });

                if shape_to_play == self.ai_shape {
                    map.max()
                        .expect("We should never iterate over zero empty cells")
                } else {
                    map.min()
                        .expect("We should never iterate over zero empty cells")
                }
            }
        }
    }

    /// Return the optimal position for the AI to play in.
    ///
    /// The optimal move is generated by looking at all possible moves and evaluating each
    /// resultant position, and picking the move which generates the best outcome for the AI.
    /// See [`evaluate_position`](Board::evaluate_position).
    ///
    /// # Errors
    ///
    /// If the board is full, then we return `None`.
    pub fn generate_ai_move(&self) -> Option<Coord> {
        if self.empty_cells().is_empty() {
            return None;
        }

        let empty_cells = self.empty_cells();

        // Go in the center when possible
        if empty_cells.contains(&(1, 1)) {
            Some((1, 1))

        // When there's only one shape on the board and the center is full
        } else if empty_cells.len() >= 8 {
            Some(
                **[(0, 0), (2, 2), (0, 2), (2, 0)]
                    .iter()
                    .filter(|&x| empty_cells.contains(x))
                    .collect::<Vec<_>>()
                    .choose(&mut rand::thread_rng())
                    .unwrap(),
            )
        } else {
            Some(
                empty_cells
                    .par_iter()
                    .map(|&(x, y)| -> (Coord, i8) {
                        let mut new_board = self.clone();
                        new_board.cells[x][y] = Some(self.ai_shape);
                        ((x, y), new_board.evaluate_position(self.ai_shape.other()))
                    })
                    .collect::<Vec<_>>()
                    .iter()
                    .max_set_by_key(|&(_, x)| x)
                    .choose(&mut rand::thread_rng())
                    .unwrap()
                    .0,
            )
        }
    }
}

impl Default for Board {
    /// Return a board with [`O`](CellShape::O) as the default AI shape.
    fn default() -> Self {
        Self::new(CellShape::O)
    }
}

#[cfg(any(test, feature = "bench"))]
impl Board {
    pub fn with_cell_array(cells: [[Option<CellShape>; 3]; 3]) -> Self {
        Self {
            cells,
            ..Default::default()
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::normal::test_utils::make_board;

    #[test]
    fn get_empty_cells_test() {
        let board = Board::default();
        assert_eq!(
            board.empty_cells(),
            vec![
                (0, 0),
                (0, 1),
                (0, 2),
                (1, 0),
                (1, 1),
                (1, 2),
                (2, 0),
                (2, 1),
                (2, 2),
            ]
        );

        // X|O|X
        //  |X|O
        //  |O|X
        let board = make_board!(X O X; _ X O; _ O X);
        assert_eq!(board.empty_cells(), vec![(0, 1), (0, 2)]);

        // O|X|O
        // X|O|X
        // O|X|X
        let board = make_board!(O X O; X O X; O X X);
        assert_eq!(board.empty_cells(), vec![]);

        // X|O|O
        // O|X|X
        // X|X|O
        let board = make_board!(X O O; O X X; X X O);
        assert_eq!(board.empty_cells(), vec![]);

        // X|X|X
        // O|O|O
        //  | |
        let board = make_board!(X X X; O O O; _);
        assert_eq!(board.empty_cells(), vec![(0, 2), (1, 2), (2, 2)]);
    }

    #[test]
    fn evaluate_position_test() {
        // X|O|
        //  |X|O
        // O| |X
        let board = make_board!(X O _; _ X O; O _ X);
        // Whoever plays in this position, it's bad because the player (X) has won
        assert_eq!(board.evaluate_position(CellShape::X), -100);
        assert_eq!(board.evaluate_position(CellShape::O), -100);

        // O|X|
        //  |O|X
        // X| |O
        let board = make_board!(O X _; _ O X; X _ O);
        // Whoever plays in this position, it's good because the AI (O) has won
        assert_eq!(board.evaluate_position(CellShape::X), 100);
        assert_eq!(board.evaluate_position(CellShape::O), 100);

        // X|O|
        // X|O|O
        // X|O|
        let board = make_board!(X O _; X O O; X O _);
        // Multiple winners is a draw
        assert_eq!(board.evaluate_position(CellShape::X), 0);
        assert_eq!(board.evaluate_position(CellShape::O), 0);

        // X|O|
        //  |X|O
        //  | |
        let board = make_board!(X O _; _ X _; _);
        assert_eq!(board.evaluate_position(CellShape::X), -90);

        // X|O|X
        // X|X|O
        // O| |O
        let board = make_board!(X O X; X X O; O _ O);
        assert_eq!(board.evaluate_position(CellShape::X), 0);
        assert_eq!(board.evaluate_position(CellShape::O), 90);

        // X|O|X
        //  |X|O
        // O|X|O
        let board = make_board!(X O X; _ X O; O X O);
        assert_eq!(board.evaluate_position(CellShape::X), 0);
        assert_eq!(board.evaluate_position(CellShape::O), 0);
    }

    #[test]
    fn generate_ai_move_test() {
        //  | |X
        //  |X|O
        //  | |
        let board = make_board!(_ _ X; _ X O; _);
        assert_eq!(board.generate_ai_move(), Some((0, 2)));

        // X|O|X
        // X|O|
        //  | |
        let board = make_board!(X O X; X O _; _);
        assert_eq!(board.generate_ai_move(), Some((1, 2)));

        //  | |O
        //  |X|
        //  | |X
        let board = make_board!(_ _ O; _ X _; _ _ X);
        assert_eq!(board.generate_ai_move(), Some((0, 0)));

        // O| |O
        //  |X|
        // X| |X
        let board = make_board!(O _ O; _ X _; X _ X);
        assert_eq!(board.generate_ai_move(), Some((1, 0)));

        // O| |O
        //  |X|
        //  |X|X
        let board = make_board!(O _ O; _ X _; _ X X);
        assert_eq!(board.generate_ai_move(), Some((1, 0)));

        // O|X|X
        // X|O|O
        // O|X|X
        let board = make_board!(O X X; X O O; O X X);
        assert_eq!(board.generate_ai_move(), None);

        // O|O|X
        // O|X|X
        // O|X|X
        let board = make_board!(O O X; O X X; O X X);
        assert_eq!(board.generate_ai_move(), None);
    }
}
