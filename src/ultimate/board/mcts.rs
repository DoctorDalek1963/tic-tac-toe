//! This module provides functionality for an AI based on Monte Carlo tree search (MCTS).

use rand::{seq::SliceRandom, thread_rng};

use super::GlobalBoard;
use crate::ultimate::GlobalCoord;

/// The coordinates of all the cells in the global board.
#[rustfmt::skip]
const ALL_CELLS: [GlobalCoord; 81] = [
    (0, 0, (0, 0)), (0, 0, (1, 0)), (0, 0, (2, 0)),
    (0, 0, (0, 1)), (0, 0, (1, 1)), (0, 0, (2, 1)),
    (0, 0, (0, 2)), (0, 0, (1, 2)), (0, 0, (2, 2)),

    (1, 0, (0, 0)), (1, 0, (1, 0)), (1, 0, (2, 0)),
    (1, 0, (0, 1)), (1, 0, (1, 1)), (1, 0, (2, 1)),
    (1, 0, (0, 2)), (1, 0, (1, 2)), (1, 0, (2, 2)),

    (2, 0, (0, 0)), (2, 0, (1, 0)), (2, 0, (2, 0)),
    (2, 0, (0, 1)), (2, 0, (1, 1)), (2, 0, (2, 1)),
    (2, 0, (0, 2)), (2, 0, (1, 2)), (2, 0, (2, 2)),

    (0, 1, (0, 0)), (0, 1, (1, 0)), (0, 1, (2, 0)),
    (0, 1, (0, 1)), (0, 1, (1, 1)), (0, 1, (2, 1)),
    (0, 1, (0, 2)), (0, 1, (1, 2)), (0, 1, (2, 2)),

    (1, 1, (0, 0)), (1, 1, (1, 0)), (1, 1, (2, 0)),
    (1, 1, (0, 1)), (1, 1, (1, 1)), (1, 1, (2, 1)),
    (1, 1, (0, 2)), (1, 1, (1, 2)), (1, 1, (2, 2)),

    (2, 1, (0, 0)), (2, 1, (1, 0)), (2, 1, (2, 0)),
    (2, 1, (0, 1)), (2, 1, (1, 1)), (2, 1, (2, 1)),
    (2, 1, (0, 2)), (2, 1, (1, 2)), (2, 1, (2, 2)),

    (0, 2, (0, 0)), (0, 2, (1, 0)), (0, 2, (2, 0)),
    (0, 2, (0, 1)), (0, 2, (1, 1)), (0, 2, (2, 1)),
    (0, 2, (0, 2)), (0, 2, (1, 2)), (0, 2, (2, 2)),

    (1, 2, (0, 0)), (1, 2, (1, 0)), (1, 2, (2, 0)),
    (1, 2, (0, 1)), (1, 2, (1, 1)), (1, 2, (2, 1)),
    (1, 2, (0, 2)), (1, 2, (1, 2)), (1, 2, (2, 2)),

    (2, 2, (0, 0)), (2, 2, (1, 0)), (2, 2, (2, 0)),
    (2, 2, (0, 1)), (2, 2, (1, 1)), (2, 2, (2, 1)),
    (2, 2, (0, 2)), (2, 2, (1, 2)), (2, 2, (2, 2)),
];

impl GlobalBoard {
    /// Return a vec of all the legal moves on the global board.
    fn legal_moves(&self) -> Vec<GlobalCoord> {
        match self.next_local_board() {
            None => ALL_CELLS.to_vec(),
            #[rustfmt::skip]
            Some((x, y)) => vec![
                (x, y, (0, 0)), (x, y, (1, 0)), (x, y, (2, 0)),
                (x, y, (0, 1)), (x, y, (1, 1)), (x, y, (2, 1)),
                (x, y, (0, 2)), (x, y, (1, 2)), (x, y, (2, 2)),
            ],
        }
        .iter()
        .filter_map(|&(x, y, (lx, ly))| {
            if self.local_boards[x][y].cells[lx][ly].is_none() {
                Some((x, y, (lx, ly)))
            } else {
                None
            }
        })
        .collect()
    }

    /// Return the AI-chosen optimal move, which could be none if the board is full.
    pub fn generate_ai_move(&self) -> Option<GlobalCoord> {
        let legal_moves = self.legal_moves();

        if legal_moves.is_empty() {
            return None;
        }

        Some(*legal_moves.choose(&mut thread_rng()).unwrap())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ultimate::test_utils::make_global_board;

    #[test]
    fn legal_moves_test() {
        let board = GlobalBoard::default();
        assert_eq!(board.legal_moves(), ALL_CELLS);

        let board = make_global_board! {
            next = None,
            (_; _ X _; _) (_; _ X _; _) (_; _ X _; _);
            (_; _ X _; _) (O O O; O X O; O O O) (_; _ X _; _);
            (_; _ X _; _) (_; _ X _; _) (_; _ X _; _);
        };
        #[rustfmt::skip]
        assert_eq!(
            board.legal_moves(),
            vec![
                (0, 0, (0, 0)), (0, 0, (1, 0)), (0, 0, (2, 0)),
                (0, 0, (0, 1)), (0, 0, (2, 1)),
                (0, 0, (0, 2)), (0, 0, (1, 2)), (0, 0, (2, 2)),

                (1, 0, (0, 0)), (1, 0, (1, 0)), (1, 0, (2, 0)),
                (1, 0, (0, 1)), (1, 0, (2, 1)),
                (1, 0, (0, 2)), (1, 0, (1, 2)), (1, 0, (2, 2)),

                (2, 0, (0, 0)), (2, 0, (1, 0)), (2, 0, (2, 0)),
                (2, 0, (0, 1)), (2, 0, (2, 1)),
                (2, 0, (0, 2)), (2, 0, (1, 2)), (2, 0, (2, 2)),

                (0, 1, (0, 0)), (0, 1, (1, 0)), (0, 1, (2, 0)),
                (0, 1, (0, 1)), (0, 1, (2, 1)),
                (0, 1, (0, 2)), (0, 1, (1, 2)), (0, 1, (2, 2)),

                (2, 1, (0, 0)), (2, 1, (1, 0)), (2, 1, (2, 0)),
                (2, 1, (0, 1)), (2, 1, (2, 1)),
                (2, 1, (0, 2)), (2, 1, (1, 2)), (2, 1, (2, 2)),

                (0, 2, (0, 0)), (0, 2, (1, 0)), (0, 2, (2, 0)),
                (0, 2, (0, 1)), (0, 2, (2, 1)),
                (0, 2, (0, 2)), (0, 2, (1, 2)), (0, 2, (2, 2)),

                (1, 2, (0, 0)), (1, 2, (1, 0)), (1, 2, (2, 0)),
                (1, 2, (0, 1)), (1, 2, (2, 1)),
                (1, 2, (0, 2)), (1, 2, (1, 2)), (1, 2, (2, 2)),

                (2, 2, (0, 0)), (2, 2, (1, 0)), (2, 2, (2, 0)),
                (2, 2, (0, 1)), (2, 2, (2, 1)),
                (2, 2, (0, 2)), (2, 2, (1, 2)), (2, 2, (2, 2)),
            ]
        );

        let board = make_global_board! {
            next = (1, 1),
            () () ();
            () (_; _ X _; _) ();
            () () ();
        };
        #[rustfmt::skip]
        assert_eq!(
            board.legal_moves(),
            vec![
                (1, 1, (0, 0)), (1, 1, (1, 0)), (1, 1, (2, 0)),
                (1, 1, (0, 1)), (1, 1, (2, 1)),
                (1, 1, (0, 2)), (1, 1, (1, 2)), (1, 1, (2, 2)),
            ]
        );

        let board = make_global_board! {
            next = (0, 0),
            () () ();
            (_; _ X _; O O _) (_; O X X; O _ _) (_; _ O _; _);
            (O _ _; X _ _; X _ _) (_; X _ _; _) ();
        };
        #[rustfmt::skip]
        assert_eq!(
            board.legal_moves(),
            vec![
                (0, 0, (0, 0)), (0, 0, (1, 0)), (0, 0, (2, 0)),
                (0, 0, (0, 1)), (0, 0, (1, 1)), (0, 0, (2, 1)),
                (0, 0, (0, 2)), (0, 0, (1, 2)), (0, 0, (2, 2)),
            ]
        );

        let board = make_global_board! {
            next = (1, 1),
            (_; _ X _; _) () ();
            (_; _ X _; O O _) (_; O X X; O _ _) (_; _ O _; _);
            (O _ _; X _ _; X _ _) (_; X _ _; _) ();
        };
        assert_eq!(
            board.legal_moves(),
            vec![
                (1, 1, (0, 0)),
                (1, 1, (1, 0)),
                (1, 1, (2, 0)),
                (1, 1, (1, 2)),
                (1, 1, (2, 2)),
            ]
        );
    }
}
